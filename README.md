[TOC]



# Inside-in-JVM

## 注意事项

1. 代码下载地址（http://www.hzbook.com/）




........

## 一. 走进Java

### 1.走进Java

主要讲了JDK的发展史，和JVM的发展

HotSpot虚拟机 是使用最为广泛的虚拟机

## 二.自动内存管理

java和C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人想出来。

### 2.Java内存区域与内存溢出异常

#### 2.1 概述

#### 2.2运行时的数据区域

根据Java虚拟机规范的规定，Java虚拟机所管理的内存将会包含以下几个运行时数据区域

##### 2.2.1 程序计数器

​	程序计数器（Program Counter Register） 是当前线程所执行的字节码的行号指示器。

​	字节码解释器工作时改变这个计数器的值，来选择下一条需要执行的字节码指令，程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等都是依赖这个计数器完成。

​	Java多线程通过切换、分配处理器执行时间来实现。所以为了线程切换后能恢复到正确的位置，每条线程需要有一个独立的程序计数器。

​	如果线程正在执行一个Java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址。如果执行的是本地方法，这个计数器的值为空（Undefined）。

​	此内存区域是一个在《Java虚拟机规范》里没有规定任何OutOfMemoryError情况的区域。

##### 2.2.2 虚拟机栈

​	Java Virtual Machine Stack 也是线程私有的，生命周期和线程一样。	

​	每个方法被执行的时候，Java虚拟机会同步创建一个栈帧（Stack Frame）用于存储 局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈从入栈到出栈的过程。

​	**局部变量表** 存放了编译器可知的各种基本数据类型（boolean、byte、short、int、long、float、double、char） 、对象引用 和 ReturnAddress类型（指向一条字节码指令的地址）。

​	数据类型在**局部变量表**是由**局部变量槽（Slot）**来表示，long和double是两个变量槽，其余是一个。所以方法进入的时候，需要在栈帧中分配多大的局部变量空间是一定的（变量槽一定，但是不同的虚拟机实现一个变量槽的大小不一定）。

​	《Java虚拟机规范》异常：线程请求的栈深度大于虚拟机所允许的最大深度，抛出 StackOverflowError 异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError。

（HotSpot虚拟机栈是不可扩展的，只要线程申请成功了就不会有OOM，但是申请时就失败，是有OOM异常的）

##### 2.2.3 本地方法栈

##### 2.2.4 Java堆

##### 2.2.5 方法区

##### 2.2.6 运行时常量池

##### 2.2.7 方法区直接内存











## Last 个人记录一下学习JVM的一些思考

